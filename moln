#!/bin/bash
#
# Copyright (C) 2022-2023 Fredrik Öhrström (spdx: MIT)
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

MOLN=$(realpath $0)
verbose=false
debug=false

if [ -z "$AWS_ACCOUNT" ]
then
    if [ ! -f $HOME/.config/moln/moln.env ]
    then
        mkdir -p $HOME/.config/moln
        echo "AWS_ACCOUNT=$(aws sts get-caller-identity --output text --query Account)"  >> $HOME/.config/moln/moln.env
        echo "AWS_DEFAULT_REGION=$(aws configure get region)" >> $HOME/.config/moln/moln.env
    fi
    . $HOME/.config/moln/moln.env
fi

##############################################################
normal=$(printf '\033[0m')
yellow=$(printf '\033[33m')
blue=$(printf '\033[34m')
red=$(printf '\033[31m')
green=$(printf '\033[32m')

NA="${red}NA${normal}"

function cmd_columnize_post
{
    # Default post function when a pre function has been specified.
    column -t -s $'\t'
}

function getTag
{
    local NAME="$1"
    local JSON="$2"
    local HASTAGS=$(echo "$JSON" | jq -jr '.Tags')
    if [ "$HASTAGS" = "null" ]
    then
        # Tags does not exist at all.
        echo "$NA"
    else
        local VAL=$(echo "$JSON" | jq -jr '(.Tags[] | select (.Key == "'$NAME'") | .Value)')
        if [ -n "$VAL" ]
        then
            echo "$VAL"
        else
            echo "$NA"
        fi
    fi
}

function duration_since
{
    # Take a timestamp as an argument and output: 4m (for 4minutes) 4h (for 4 hours) 8d (for 8 days)
    TIMESTAMP="$1"
    THEN=$(date -d "$TIMESTAMP" "+%s")
    NOW=$(date "+%s")
    let DIFF=($NOW-$THEN)/86400
    if [ "$DIFF" = "0" ]
    then
        let DIFF=($NOW-$THEN)/3600
        if [ "$DIFF" = "0" ]
        then
            let DIFF=($NOW-$THEN)/60
            echo "${DIFF}m"
        else
            echo "${DIFF}h"
        fi
    else
        echo "${DIFF}d"
    fi
}

function verbose
{
    if [ "$verbose" = "true" ]
    then
        >2 echo "$@"
    fi
}

function debug
{
    if [ "$verbose" = "true" ] || [ "$debug" = "true" ]
    then
        >2 echo "$@"
    fi
}
cmds_BASIC="whoami"

function help_whoami
{
    echo "Display active account/identity."
}

CMD_AWS_WHOAMI="aws sts get-caller-identity"
function cmd_aws_whoami
{
    $CMD_AWS_WHOAMI
}

CMD_AZURE_WHOAMI="az account list"
function cmd_azure_whoami
{
    $CMD_AZURE_WHOAMI
}

CMD_GCLOUD_WHOAMI="gcloud config list"
function cmd_gcloud_whoami
{
    $CMD_GCLOUD_WHOAMI
}
cmds_BUCKET="\
list-buckets \
list-bucket-contents \
"

function help_list_buckets
{
    echo "List storage buckets, ie aws s3/gcloud storage/azure blobs."
}

function cmd_list_buckets_pre
{
    printf "CLOUD\tNAME\t\n"
}

function help_list_bucket_content
{
    echo "List bucket contents."
}
function summarize_aws_bucket
{
    # Expects a compact json on a single line, no extra spaces.
    JSON="$1"
    if [ -n "$JSON" ]
    then
        NAME=$(echo "$JSON" | jq -jr '.Name')
        printf "aws\t$NAME\t\n"
    fi
}

CMD_AWS_LIST_BUCKETS='aws s3api list-buckets --output json'
function cmd_aws_list_buckets
{
    $CMD_AWS_LIST_BUCKETS | jq -c '.Buckets[]' | while IFS=$"\n" read -r info; do summarize_aws_bucket "$info" ; done
}
function summarize_azure_bucket
{
    # Expects a compact json on a single line, no extra spaces.
    JSON="$1"
    if [ -n "$JSON" ]
    then
        NAME=$(echo "$JSON" | jq -jr '.Name')
        printf "aws\t$NAME\t\n"
    fi
}

function cmd_azure_list_buckets
{
    echo "Not implemented"
}
function summarize_gcloud_bucket
{
    # Expects a compact json on a single line, no extra spaces.
    JSON="$1"
    if [ -n "$JSON" ]
    then
        NAME=$(echo "$JSON" | jq -jr '.Name')
        printf "aws\t$NAME\t\n"
    fi
}

function cmd_gcloud_list_buckets
{
    echo "Not implemented"
}
cmds_COST="list-costs"

function help_list_costs
{
    echo "Print a summary of monthly costs for the last 12 months."
}
function cmd_aws_list_costs
{
cat > /tmp/filters.json <<EOF
{
    "Dimensions": {
        "Key": "SERVICE",
        "Values": [
            "Amazon Elastic Compute Cloud - Compute"
        ]
    }
}
EOF

    aws ce get-cost-and-usage \
    --time-period Start=2022-01-01,End=2023-02-01 \
    --metrics "BlendedCost" \
    --granularity MONTHLY \
    --filter='{ "Dimensions": { "Key": "SERVICE", "Values": [ "Amazon Elastic Compute Cloud - Compute" ] } }' \
    | tee costs.json
}
#    --filter file:///tmp/filters.json \
cmds_DNS="list-hosted-zones list-dns-records upsert-dns-record remove-dns-record list-domains"

function help_list_hosted_zones
{
    echo "List zones the dns is configured to serve."
}

function help_list_dns_records
{
    echo "List dns records in a zone."
}

function help_list_domains
{
    echo "List dns domains."
}

function cmd_list_hosted_zones_pre
{
    printf "CLOUD\tDOMAIN\tPRIVATE\tID\t\n"
}

function cmd_aws_list_hosted_zones
{
    aws route53 --region us-east-1 list-hosted-zones | \
        jq -r '.HostedZones[] | [ "aws", .Name, .Config.PrivateZone, .Id ] | join("\t")'
}

function cmd_list_dns_records_pre
{
    printf "CLOUD\tDOMAIN\tTYPE\tTTL\tIP\t\n"
}

function cmd_aws_list_dns_records
{
    DOMAIN=$1

    ID=$(aws route53 list-hosted-zones-by-name --dns-name ${DOMAIN} --query HostedZones[].Id --output text | cut -d/ -f3)

    aws route53 list-resource-record-sets --hosted-zone-id=${ID} | \
        jq -r '.ResourceRecordSets[] | [ "aws", .Name, .Type, .TTL, (.ResourceRecords[].Value )  ] | join("\t")' \
        | grep -v "SOA" | grep -v "NS"
}

function cmd_list_domains_pre
{
    printf "CLOUD\tDOMAIN\tAUTO_RENEW\tTRANSFER_LOCK\tEXPIRES\t\n"
}

function cmd_aws_list_domains
{
    aws route53domains --region us-east-1 list-domains | \
        jq -r '.Domains[] | [ "aws", .DomainName, .AutoRenew, .TransferLock, .Expiry ] | join("\t")'
}

function cmd_aws_upsert_dns_record
{
    # Usage: moln aws upsert-dns-record testur.ferrrbarr.com A 10.11.12.13
    NAME=$1
    TYPE=$2
    DEST=$3

    if [ -z "$NAME" ] || [ -z "$TYPE" ] || [ -z "$DEST" ]
    then
        echo "Usage: moln aws upsert-dns-record alfa.beta.com A 1.2.3.4"
        exit 1
    fi
    # Grab the host name.
    HOST=${NAME%%.*}
    # Grab everything after the first .
    DOMAIN=${NAME#*.}

    if [ -z "$DOMAIN" ]
    then
        echo "You must have a full host.domain.com specified!"
        exit 1
    fi

    FILE=$(mktemp create_record_XXXXXXX.json)
    cat > $FILE <<EOF
{
    "Comment": "CREATE/DELETE/UPSERT a record ",
    "Changes": [{
    "Action": "UPSERT",
    "ResourceRecordSet": {
        "Name": "${NAME}.",
        "Type": "A",
        "TTL": 300,
        "ResourceRecords": [{ "Value": "${DEST}"}]
    }}]
}
EOF

    ID=$(aws route53 list-hosted-zones-by-name --dns-name ${DOMAIN} --query HostedZones[].Id --output text | cut -d/ -f3)

    echo "Adding $HOST $TYPE $DEST to domain $DOMAIN $ID"

    aws route53 change-resource-record-sets --hosted-zone-id ${ID} --change-batch file://${FILE}
}

function cmd_aws_remove_dns_record
{
    # Usage: moln aws remove-dns-record testur.ferrrbarr.com
    NAME=$1

    if [ -z "$NAME" ]
    then
        echo "Usage: moln aws remove-dns-record alfa.beta.com"
        exit 1
    fi
    # Grab the host name.
    HOST=${NAME%%.*}
    # Grab everything after the first .
    DOMAIN=${NAME#*.}

    if [ -z "$DOMAIN" ]
    then
        echo "You must have a full host.domain.com specified!"
        exit 1
    fi

    ID=$(aws route53 list-hosted-zones-by-name --dns-name ${DOMAIN} --query HostedZones[].Id --output text | cut -d/ -f3)

    FIELDS=$(aws route53 list-resource-record-sets --hosted-zone-id ${ID} | \
                 jq -r '.ResourceRecordSets[] | [ .Name, .Type, .TTL, (.ResourceRecords[].Value )  ] | join("\t")' | \
          grep "$NAME")

    NAMEO=$(echo "$FIELDS" | cut -f 1)
    TYPE=$(echo "$FIELDS" | cut -f 2)
    TTL=$(echo "$FIELDS" | cut -f 3)
    DEST=$(echo "$FIELDS" | cut -f 4)

    if [ -z "$NAMEO" ]
    then
        echo "No record for $NAME exists!"
        exit 1
    fi

    echo "Removing $HOST $TYPE $DEST from domain $DOMAIN $ID"

    FILE=$(mktemp remove_record_XXXXXXX.json)
    cat > $FILE <<EOF
{
    "Comment": "CREATE/DELETE/UPSERT a record ",
    "Changes": [{
    "Action": "DELETE",
    "ResourceRecordSet": {
        "Name": "${NAME}",
        "Type": "${TYPE}",
        "TTL": ${TTL},
        "ResourceRecords": [{ "Value": "${DEST}"}]
    }}]
}
EOF

    aws route53 change-resource-record-sets --hosted-zone-id ${ID} --change-batch file://${FILE}
}
# Groups part of moln. Copyright (C) 2022 Fredrik Öhrström license spdx: MIT

cmds_Groups="list-groups-for-user list-attached-group-policies"

## groups ########################################################
cmds_CLI="install"

function help_install
{
    echo "Install the specified cloud cli."
}

function cmd_install_pre {
    mkdir -p $HOME/opt
    mkdir -p $HOME/bin
    if ! command -v unzip &> /dev/null
    then
        echo "Please install the unzip command!"
        exit 1
    fi
}

function cmd_aws_install
{
    echo "Fetching https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip into $HOME/opt"
    cd $HOME/opt
    curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
    echo "Unzipping downloaded cli zip..."
    unzip -q awscliv2.zip
    echo "Now running: ./aws/install -i $HOME/opt/aws-cli -b $HOME/bin"
    ./aws/install -i $HOME/opt/aws-cli -b $HOME/bin
    echo "You can now delete the directory ./aws"
    echo "Done."
}

function cmd_gcloud_install {
    echo "Fetching https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-cli-407.0.0-linux-x86_64.tar.gz"
    cd $HOME/opt
    curl https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-cli-407.0.0-linux-x86_64.tar.gz -o gcsdk.tgz
    echo "Untaring downloaded cli tgz..."
    tar xzf gcsdk.tgz
    echo "Now running: ./google-cloud-sdk/install.sh"
    ./google-cloud-sdk/install.sh
    echo "You can now delete ./google-cloud-sdk"
    echo "Done."
}

function cmd_azure_install {
    echo "Removing azure-cli to avoid any old versions in Ubuntu universe 20..." ;
    sudo apt remove azure-cli -y && sudo apt autoremove -y
    sudo apt-get update
    echo "Installing necessary tools to install"
    sudo apt-get install ca-certificates curl apt-transport-https lsb-release gnupg
    echo "Installing microsoft gpg public key."
    curl -sL https://packages.microsoft.com/keys/microsoft.asc | \
        gpg --dearmor | \
        sudo tee /etc/apt/trusted.gpg.d/microsoft.gpg > /dev/null
    echo "Adding microsoft deb repo to apt."
    AZ_REPO=$(lsb_release -cs)
    echo "deb [arch=amd64] https://packages.microsoft.com/repos/azure-cli/ $AZ_REPO main" | \
        sudo tee /etc/apt/sources.list.d/azure-cli.list
    echo "Installing azure-cli."
    sudo apt-get update
    sudo apt-get install azure-cli
    echo "Done."
}
function cmd_aws_install
{
    echo "Fetching https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip into $HOME/opt"
    cd $HOME/opt
    curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
    echo "Unzipping downloaded cli zip..."
    unzip -q awscliv2.zip
    echo "Now running: ./aws/install -i $HOME/opt/aws-cli -b $HOME/bin"
    ./aws/install -i $HOME/opt/aws-cli -b $HOME/bin
    echo "You can now delete the directory ./aws"
    echo "Done."
}
function cmd_azure_install
{
    echo "Removing azure-cli to avoid any old versions in Ubuntu universe 20..." ;
    sudo apt remove azure-cli -y && sudo apt autoremove -y
    sudo apt-get update
    echo "Installing necessary tools to install"
    sudo apt-get install ca-certificates curl apt-transport-https lsb-release gnupg
    echo "Installing microsoft gpg public key."
    curl -sL https://packages.microsoft.com/keys/microsoft.asc | \
        gpg --dearmor | \
        sudo tee /etc/apt/trusted.gpg.d/microsoft.gpg > /dev/null
    echo "Adding microsoft deb repo to apt."
    AZ_REPO=$(lsb_release -cs)
    echo "deb [arch=amd64] https://packages.microsoft.com/repos/azure-cli/ $AZ_REPO main" | \
        sudo tee /etc/apt/sources.list.d/azure-cli.list
    echo "Installing azure-cli."
    sudo apt-get update
    sudo apt-get install azure-cli
    echo "Done."
}
function cmd_gcloud_install
{
    echo "Fetching https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-cli-407.0.0-linux-x86_64.tar.gz"
    cd $HOME/opt
    curl https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-cli-407.0.0-linux-x86_64.tar.gz -o gcsdk.tgz
    echo "Untaring downloaded cli tgz..."
    tar xzf gcsdk.tgz
    echo "Now running: ./google-cloud-sdk/install.sh"
    ./google-cloud-sdk/install.sh
    echo "You can now delete ./google-cloud-sdk"
    echo "Done."
}
cmds_IP="list-ips"

function help_list_ips
{
    echo "List allocated external ip numbers."
}

function cmd_list_ips_pre
{
    printf "CLOUD\tNAME\tCIDR_BLOCK\tSTATUS\tID\t\n"
}
function summarize_aws_ip
{
    # Expects a compact json on a single line, no extra spaces.
    JSON="$1"
    if [ -n "$JSON" ]
    then
        echo "$1" | jq .
    fi
}

CMD_AWS_LIST_IPS='aws ec2 describe-addresses'
function cmd_aws_list_ips
{
    $CMD_AWS_LIST_IPS | jq -c '.Addresses[]' | while IFS=$"\n" read -r info; do summarize_aws_ip "$info" ; done
}
cmds_POLICY="list-policies"

function help_list_policies
{
    echo "List iam policies."
}
CMD_AWS_LIST_POLICIES='aws iam list-policies'
function cmd_aws_list_policies
{
    $CMD_AWS_LIST_POLICIES
}
# --query "Policies[].Arn"
cmds_ROLE=" assume-role list-roles"

function help_assume_role
{
    echo "Start a subshell with the rights of the assumed role."
}

function help_list_roles
{
    echo "List iam roles."
}
CMD_AWS_ASSUME_ROLE='aws sts assume-role --role-arn "arn:aws:iam::${AWS_ACCOUNT}:role/$ROLE" --role-session-name "$SESSION"'
function cmd_aws_assume_role
{
    ROLE="$1"
    SESSION="$2"

    ROLE_ARN=arn:aws:iam::${AWS_ACCOUNT}:role/$ROLE_NAME

    if [ -z "$SESSION" ] || [ -z "$ROLE" ]
    then
        echo "Usage: moln aws assume-role <role> <session>"
        exit 1
    fi
    eval $CMD_AWS_ASSUME_ROLE > session.token
    ROLE_SESSION_NAME=$(jq .AssumedRoleUser.Arn session.token | tr -d '"' | cut -f 2- -d '/')
    echo "Role session ${ROLE_SESSION_NAME} expires $(jq .Credentials.Expiration session.token | tr -d '"')"
    AWS_ACCESS_KEY_ID=$(jq .Credentials.AccessKeyId session.token | tr -d '"') \
    AWS_SECRET_ACCESS_KEY=$(jq .Credentials.SecretAccessKey session.token | tr -d '"') \
    AWS_SESSION_TOKEN=$(jq .Credentials.SessionToken session.token | tr -d '"') \
    bash --rcfile <(echo 'export PS1="${PS1}\[\033[01;31m\]['${ROLE_SESSION_NAME}']\[\033[00m\]\$ "')
}

CMD_AWS_LIST_ROLES='aws iam list-roles'
function cmd_aws_list_roles
{
    $CMD_AWS_LIST_ROLES --query  "Roles[].Arn"
}
cmds_SUBNET="list-subnets"

function help_list_subnets
{
    echo "List all subnets."
}

function cmd_list_subnets_pre
{
    printf "CLOUD\tNAME\tCIDR_BLOCK\tSTATUS\tID\t\n"
}
function summarize_aws_subnet
{
    # Expects a compact json on a single line, no extra spaces.
    JSON="$1"
    if [ -n "$JSON" ]
    then
        NAME='Not set!'
        if [ "$(echo "$JSON" | jq -jr '.Tags')" != "null" ]
        then
            NAME=$(echo "$JSON" | jq -jr '(.Tags[] | select (.Key == "Name") | .Value)')
        fi
        ID=$(echo "$JSON" | jq -jr '.VpcId')
        STATUS=$(echo "$JSON" | jq -jr '.State')
        CIDR_BLOCK=$(echo "$JSON" | jq -jr '.CidrBlock')
        IS_DEFAULT=
        if [ "$(echo "$JSON" | jq -jr '.IsDefault')" = "true" ]
        then
            IS_DEFAULT=DEFAULT
        fi

        printf "aws\t$NAME\t$CIDR_BLOCK\t$STATUS\t$ID\t$IS_DEFAULT\n"
    fi
}

CMD_AWS_LIST_SUBNETS='aws ec2 describe-subnets'
function cmd_aws_list_subnets
{
    $CMD_AWS_LIST_SUBNETS | jq -c '.Subnets[]' | while IFS=$"\n" read -r info; do summarize_aws_subnet "$info" ; done | sort
}
cmds_USER="list-users"

function help_list_users
{
    echo "List users in cloud account."
}

function cmd_list_users_pre
{
    printf "CLOUD\tNAME\tID\t\n"
}
function summarize_aws_user
{
    # Expects a compact json on a single line, no extra spaces.
    JSON="$1"
    if [ -n "$JSON" ]
    then
        NAME=$(echo "$JSON" | jq -jr '.UserName')
        ID=$(echo "$JSON" | jq -jr '.UserId')
        printf "aws\t$NAME\t$ID\t\n"
    fi
}

CMD_AWS_LIST_USERS='aws iam list-users'
function cmd_aws_list_users
{
    $CMD_AWS_LIST_USERS | jq -c '.Users[]' | while IFS=$"\n" read -r info; do summarize_aws_user "$info" ; done
}
function summarize_azure_user
{
    # Expects a compact json on a single line, no extra spaces.
    JSON="$1"
    if [ -n "$JSON" ]
    then
        NAME=$(echo "$JSON" | jq -jr '.displayName')
        ID=$(echo "$JSON" | jq -jr '.id')
        printf "azure\t$NAME\t$ID\t\n"
    fi
}

CMD_AZURE_LIST_USERS='az ad user list'
function cmd_azure_list_users
{
    $CMD_AZURE_LIST_USERS | jq -c '.[]' | while IFS=$"\n" read -r info; do summarize_azure_user "$info" ; done
}
function summarize_gcloud_user
{
    # Expects a compact json on a single line, no extra spaces.
    JSON="$1"
    if [ -n "$JSON" ]
    then
        NAME=$(echo "$JSON" | jq -jr '.displayName')
        ID=$(echo "$JSON" | jq -jr '.uniqueId')
        printf "gcloud\t$NAME\t$ID\t\n"
    fi
}

CMD_GCLOUD_LIST_USERS='gcloud iam service-accounts --format=json list'
function cmd_gcloud_list_users
{
    $CMD_GCLOUD_LIST_USERS | jq -c '.[]' | while IFS=$"\n" read -r info; do summarize_gcloud_user "$info" ; done
}
# Copyright (C) 2022-2023 Fredrik Öhrström license spdx: MIT

cmds_VM="\
 create-vm-from-template\
 destroy-vm\
 list-vm-templates\
 list-vms\
 show-vm-image\
 show-vm\
 ssh_to_vm\
 start-vm\
 stop-vm\
"

function help_create_vm_from_template
{
    echo "Create a virtual machine based on an existing vm template."
}

function help_destroy_vm
{
    echo "Destroy a virtual machine."
}

function cmd_list_vm_templates
{
    echo "List templates that can be used to create new virtual machines."
}

function cmd_list_vm_images
{
    echo "List virtual machine images."
}

function cmd_list_vm_images_pre
{
    printf "CLOUD\tID\tCREATION\tNAME\tDESCRIPTION\tDEPRECATION\t\n"
}

function cmd_list_vms
{
    echo "List virtual machines."
}

function cmd_list_vms_pre {
    printf "CLOUD\tNAME\tSTATE\tSINCE\tLOCATION\tTYPE\tID\tIP\t\n";
}
function cmd_aws_to_vm_id
{
    A="$1"
    if [[ $A == i-* ]]
    then
        # The argument is already an id.
        echo $A
    fi
    NAME="$1"
    aws ec2 describe-instances --filters "Name=tag:Name,Values=${NAME}" | jq -r .Reservations[].Instances[].InstanceId
}

function summarize_aws_vm_template
{
    # Expects a compact json on a single line, no extra spaces.
    JSON="$1"
    if [ "$debug" = "true" ]; then echo "$JSON"; fi
    NAME=$(echo "$JSON" | jq -jr '.LaunchTemplateName')
    ID=$(echo "$JSON" | jq -jr '.LaunchTemplateId')
    CREATION=$(echo "$JSON" | jq -jr '.CreateTime')
    printf "aws\t$ID\t$NAME\t$CREATION\t\n"
}

CMD_AWS_LIST_VM_TEMPLATES='aws ec2 describe-launch-templates'
function cmd_aws_list_vm_templates
{
    $CMD_AWS_LIST_VM_TEMPLATES | jq -c '.LaunchTemplates[]' | while IFS=$"\n" read -r info; do summarize_aws_vm_template "$info" ; done | sort -k3
}

function summarize_aws_vm_image
{
    # Expects a compact json on a single line, no extra spaces.
    JSON="$1"
    if [ "$debug" = "true" ]; then echo "$JSON"; fi
    NAME=$(echo "$JSON" | jq -jr '.Name')
    ID=$(echo "$JSON" | jq -jr '.ImageId')
    CREATION=$(echo "$JSON" | jq -jr '.CreationDate')
    DEPRECATION=$(echo "$JSON" | jq -jr '.DeprecationTime')
    DESCRIPTION=$(echo "$JSON" | jq -jr '.Description')
    printf "aws\t$ID\t$CREATION\t$NAME\t$DESCRIPTION\t$DEPRECATION\t\n"
}

function cmd_aws_list_vm_images
{
    OS=$1
    VERSION=$2
    ARCH=$3

    if [ -z "$OS" ]; then echo "You have to specify an os! (e.g. ubuntu RHEL debian)" ; exit 1; fi;
    if [ -z "$VERSION" ]; then echo "You have to specify a version! (e.g. 22.04 8.6.0 11)" ; exit 1; fi;
    if [ -z "$ARCH" ]; then ARCH="x86_64"; fi

    CMD="aws ec2 describe-images \
            --owners self amazon \
            --filters \"Name=architecture,Values=${ARCH}\" \"Name=name,Values=*${OS}*${VERSION}*\" \"Name=root-device-type,Values=ebs\" "
#            --query 'Images[*].[ImageId,CreationDate,Name,Description,DeprecationTime]' --output text \
#            | sort -k2 -r \
#            | head -n1"

    if [ "$verbose" = "true" ]; then echo "$CMD" | tr -s ' ' ; fi
    eval "$CMD" | jq -c '.Images[]' | while IFS=$"\n" read -r info; do summarize_aws_vm_image "$info" ; done | sort -k3
}

function cmd_aws_show_vm_image
{
    IMAGE=$1

    aws ec2 describe-images \
        --image-ids ${IMAGE}
}

CMD_AWS_CREATE_VM_FROM_TEMPLATE='aws ec2 run-instances
--launch-template LaunchTemplateName=${TEMPLATE_NAME}
--tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=${NAME}}]" '
function cmd_aws_create_vm_from_template
{
    NAME="$1"
    TEMPLATE_NAME="$2"
    eval CMD="$CMD_AWS_CREATE_VM_FROM_TEMPLATE"

    if [ "$verbose" = "true" ]; then echo "$CMD" | tr -s ' ' ; fi
    eval "$CMD" > ${NAME}.json

    if [ "$?" != "0" ]
    then
        echo "Failed to create $NAME"
        rm ${NAME}.json
        exit 1
    fi

    jq -r .Instances[].PrivateIpAddress ${NAME}.json > ${NAME}.ip

    echo "Successfully created ${NAME} look in ${NAME}.json ${NAME}.ip"
}

function cmd_aws_start_vm
{
    ID=$(cmd_aws_to_vm_id $1)
    aws ec2 start-instances --instance-id "$ID"
}

function cmd_aws_stop_vm
{
    ID=$(cmd_aws_to_vm_id $1)
    aws ec2 stop-instances --instance-id "$ID"
}

function cmd_aws_destroy_vm
{
    # Supply a vm id or a name.
    NAMEID="$1"
    YESREALLY=false
    if [ "$NAMEID" = "--yes-really-destroy-now" ]
    then
        NAMEID="$2"
        YESREALLY=true
    fi
    ID=$(cmd_aws_to_vm_id "$NAMEID")

    CMD="aws ec2 terminate-instances --instance-ids $ID"

    echo "Deleting vm ----------------"
    cmd_aws_show_vm $ID
    echo "----------------------------"

    if [ "$YESREALLY" = "false" ]
    then
        echo
        echo "Type \"delete $ID\" to delete vm."
        read d n
        if [ "$d" != "delete" ] || [ "$n" != "$ID" ]
        then
            echo "Nothing deleted."
            exit 1
        fi
    fi

    eval "$CMD"
}

function summarize_aws_vm
{
    # Expects a compact json on a single line, no extra spaces.
    JSON="$1"
    if [ "$verbose" = "true" ]; then echo "$JSON"; fi
    NAME=$(getTag Name "$JSON")
    ID=$(echo "$JSON" | jq -jr '.InstanceId')
    STATUS=$(echo "$JSON" | jq -jr '.State.Name')
    TIMESTAMP=$(echo "$JSON" | jq -jr .LaunchTime)
    SINCE=$(duration_since "$TIMESTAMP")
    LOCATION=$(echo "$JSON" | jq -r '.Placement.AvailabilityZone')
    IP=$(echo "$JSON" | jq -r '.PublicIpAddress')
    PIP=$(echo "$JSON" | jq -r '.PrivateIpAddress')
    TYPE=$(echo "$JSON" | jq -r '.InstanceType')

    if [ "$IP" = "null" ]; then IP="" ; fi

    printf "aws\t$NAME\t$STATUS\t$SINCE\t$LOCATION\t$TYPE\t$ID\t$PIP\t$IP\n"
}

function cmd_aws_show_vm {
    ID=$(cmd_aws_to_vm_id $1)

    aws ec2 describe-instances --instance-id=$ID | jq -c '.Reservations[].Instances[]' | while IFS=$"\n" read -r info; do summarize_aws_vm "$info" ; done
}

CMD_AWS_LIST_VMS="aws ec2 describe-instances"

function cmd_aws_list_vms {
    $CMD_AWS_LIST_VMS | jq -c '.Reservations[].Instances[]' | while IFS=$"\n" read -r info; do summarize_aws_vm "$info" ; done
}

function cmd_aws_ssh_to_vm
{
    SERVER=$1
    IP=$(aws ec2 describe-instances | jq -c '.Reservations[].Instances[]'  | jq -r '.PublicIpAddress')
    ssh -i ~/Nycklar/StockholmServersKeyPair.pem ubuntu@$IP
}

function cmd_aws_set_vm_customer
{
    SERVER="$1"
    CUSTOMER="$2"
    aws ec2 create-tags --resources $SERVER --tags 'Key=Customer,Value='$CUSTOMER
}
# Copyright (C) 2022-2023 Fredrik Öhrström license spdx: MIT

function cmd_azure_start_vm
{
    NAME=$1
    az vm start --resource-group Norge --name "$NAME" --verbose
}

function cmd_azure_stop_vm
{
    az vm deallocate --resource-group Norge --name "$NAME" --verbose
}


function summarize_azure_vm
{
    # Expects a compact json on a single line, no extra spaces.
    JSON="$1"
    if [ "$verbose" = "true" ]; then echo "$JSON"; fi
    NAME=$(echo "$JSON" | jq -r .name)
    STATUS=$(echo "$JSON" | jq -r .powerState)
    TYPE=$(echo "$JSON" | jq -r .hardwareProfile.vmSize)
    ZONE=$(echo "$JSON" | jq -r .location)
    TIMESTAMP=$(echo "$JSON" | grep -Po '"creationTimestamp":"\K.*?(?=")')
    SINCE=$(duration_since "$TIMESTAMP")
    PUBLIC_IPS=$(echo "$JSON" | jq -r .publicIps)
    printf "azure\t$NAME\t$STATUS\t$ZONE\t$TYPE\t$PUBLIC\tIPS\n"
}

CMD_AZURE_LIST_VMS="az vm list -d"
function cmd_azure_list_vms
{
    $CMD_AZURE_LIST_VMS | jq -c '.[]' | while IFS=$"\n" read -r info; do summarize_azure_vm "$info" ; done
}

function cmd_azure_ssh_to_vm
{
    SERVER=$1
    ssh azureuser@$(az vm show -d -g Norge -n $SERVER --query publicIps | tr -d '"')
}

CMD_AZURE_CREATE_VM_FROM_TEMPLATE='az foo bar ${TEMPLATE_NAME} ${NAME}'
function cmd_azure_create_vm_from_template
{
    NAME="$1"
    TEMPLATE_NAME="$2"
    eval CMD="$CMD_AWS_CREATE_VM_FROM_TEMPLATE"

    echo "Successfully created ${NAME} look in ${NAME}.json ${NAME}.ip"
}
# Copyright (C) 2022-2023 Fredrik Öhrström license spdx: MIT

function cmd_gcloud_create_vm
{
    echo "Not implemented."
}

function cmd_gcloud_start_vm
{
    NAME=$1
    gcloud compute instances start "$NAME"
}

function cmd_gcloud_stop_vm
{
    gcloud compute instances stop "$NAME"
}

function summarize_gcloud_vm {
    # Expects a compact json on a single line, no extra spaces.
    JSON="$1"
    if [ "$verbose" = "true" ]; then echo "$JSON"; fi
    NAME=$(echo "$JSON" | jq -r .name)
    STATUS=$(echo "$JSON" | jq -r .status)
    MACHINETYPE=$(echo "$JSON" | jq -r .machineType)
    ZONE=$(echo "$MACHINETYPE" | grep -Po 'zones/\K.*?(?=/)')
    TYPE=$(echo "$MACHINETYPE" | grep -Po 'machineTypes/\K.*')
    TIMESTAMP=$(echo "$JSON" | jq -r .lastStartTimestamp)
    SINCE=$(duration_since "$TIMESTAMP")
    printf "google\t$NAME\t$STATUS\t$SINCE\t$ZONE\t$TYPE\n"
}


CMD_GCLOUD_LIST_VMS="gcloud compute instances list --format json"
function cmd_gcloud_list_vms
{
    $CMD_GCLOUD_LIST_VMS | jq -c '.[]' | while IFS=$"\n" read -r info; do summarize_gcloud_vm "$info" ; done
}
cmds_VPC="create-vpc list-vpcs"

function help_list_vpcs
{
    echo "List virtual private clouds/networks, aka vpc:s and vnets."
}

function cmd_list_vpcs_pre
{
    printf "CLOUD\tNAME\tCIDR_BLOCK\tSTATUS\tID\tLOCATION\n"
}
function cmd_aws_create_vpc
{
    NAME="$1"
    if [ -z "$NAME" ]
    then
        echo "Usage: moln aws create-vpc Name"
        exit 1
    fi
    TAGS="ResourceType=string,Tags='[{Key=Name,Value=\"${NAME}\"}]'"
    echo "Create AWS vpc $NAME $TAGS"
}

function summarize_aws_vpc
{
    # Expects a compact json on a single line, no extra spaces.
    JSON="$1"
    if [ -n "$JSON" ]
    then
        NAME='Not set!'
        if [ "$(echo "$JSON" | jq -jr '.Tags')" != "null" ]
        then
            NAME=$(echo "$JSON" | jq -jr '(.Tags[] | select (.Key == "Name") | .Value)')
        fi
        ID=$(echo "$JSON" | jq -jr '.VpcId')
        STATUS=$(echo "$JSON" | jq -jr '.State')
        CIDR_BLOCK=$(echo "$JSON" | jq -jr '.CidrBlock')
        LOCATION=

        printf "aws\t$NAME\t$CIDR_BLOCK\t$STATUS\t$ID\t$LOCATION\n"
    fi
}

CMD_AWS_LIST_VPCS='aws ec2 describe-vpcs'
function cmd_aws_list_vpcs
{
    $CMD_AWS_LIST_VPCS | jq -c '.Vpcs[]' | while IFS=$"\n" read -r info; do summarize_aws_vpc "$info" ; done
}
function summarize_azure_vpc
{
    # Expects a compact json on a single line, no extra spaces.
    JSON="$1"
    if [ -n "$JSON" ]
    then
        NAME=$(echo "$JSON" | jq -jr '.name')
        LOCATION=$(echo "$JSON" | jq -jr '.location')
        ID=$(echo "$JSON" | jq -jr '.id' | cut -f 5,9 -d '/')
        STATUS=$(echo "$JSON" | jq -jr '.provisioningState')
        CIDR_BLOCK=$(echo "$JSON" | jq -jr .addressSpace.addressPrefixes[])

        printf "azure\t$NAME\t$CIDR_BLOCK\t$STATUS\t$ID\t$LOCATION\n"
    fi
}

CMD_AZURE_LIST_VPCS='az network vnet list'
function cmd_azure_list_vpcs
{
    $CMD_AZURE_LIST_VPCS | jq -c '.[]' | while IFS=$"\n" read -r info; do summarize_azure_vpc "$info" ; done
}
function summarize_gcloud_vpc
{
    # Expects a compact json on a single line, no extra spaces.
    JSON="$1"
    if [ -n "$JSON" ]
    then
        NAME='Not set!'
        if [ "$(echo "$JSON" | jq -jr '.Tags')" != "null" ]
        then
            NAME=$(echo "$JSON" | jq -jr '(.Tags[] | select (.Key == "Name") | .Value)')
        fi
        ID=$(echo "$JSON" | jq -jr '.VpcId')
        STATUS=$(echo "$JSON" | jq -jr '.State')
        CIDR_BLOCK=$(echo "$JSON" | jq -jr '.CidrBlock')
        IS_DEFAULT=
        if [ "$(echo "$JSON" | jq -jr '.IsDefault')" = "true" ]
        then
            IS_DEFAULT=DEFAULT
        fi

        printf "aws\t$NAME\t$CIDR_BLOCK\t$STATUS\t$ID\t$IS_DEFAULT\n"
    fi
}

function cmd_gcloud_list_vpcs
{
    echo GIIGIG
}
cmds_WEBAPI="list-webapi-domains"

function help_list_webapi_domains
{
    echo "List domain names mapped to web apis (REST/HTTPs) routers."
}

function cmd_list_webapi_domains_pre
{
    printf "DOMAIN\tNAME\t\n"
}
CMD_AWS_LIST_WEBAPI_DOMAINS='aws apigatewayv2 get-domain-names'
function cmd_aws_list_webapi_domains
{
    $CMD_AWS_LIST_WEBAPI_DOMAINS | jq -r -c '.Items[].DomainName'
}
#############################################################
# Moln main function entry ##################################
#############################################################

# Extract all commands from the above set of command categories by parsing this file.
all_cmds="$(eval echo $(grep ^cmds_ "$MOLN" | sed 's/\([^=]*\)=.*/\$\1/'))"

# Extract all command groups.
all_cmd_groups="$(grep ^cmds_ "$MOLN" | sed 's/\([^=]*\)=.*/\$\1/')"

# Now check the cloud selected, or all of them.
all_clouds="all aws azure gcloud"
clouds="aws azure gcloud"
verbose=false
list_help=false

if [ -t 1 ]
then
    output=terminal
else
    output=ascii
fi

while :
do
    if [[ ! "$1" =~ -[a-z_-]+ ]]
    then
        break
    fi

    if [ "$1" = "-l" ] || [ "$1" = "--list-commands" ]
    then
        echo "$all_cmds"
        exit 0
    fi

    if [ "$1" = "-lc" ] || [ "$1" = "--list-clouds" ]
    then
        echo "$all_clouds"
        exit 0
    fi

    if [ "$1" = "-v" ] || [ "$1" = "--verbose" ]
    then
        verbose=true
        shift 1
    fi

    if [ "$1" = "-d" ] || [ "$1" = "--debug" ]
    then
        verbose=true
        debug=true
        shift 1
    fi

    if [[ "$1" =~ --output=[a-z]+ ]]
    then
        output=$(echo "$1" | cut -f 2 -d '=')
        case $output in
            terminal | ascii | man | htmq | tex)
                true ;;
            *)
                echo "Not a valid output format: $output"
                echo "Use one of terminal ascii man htmq tex"
                exit 1
        esac
        shift 1
    fi

    if [ "$1" = "--list-command-coverage" ]
    then
        for i in $all_cmd_groups
        do
            echo "${blue}##### ${i#*_} ${normal}"
            echo
            {
                tmp="$(eval echo $i)"
                for j in $tmp
                do
                    info=""
                    for cloud in aws azure gcloud
                    do
                        cmdfunc="cmd_${cloud}_$(echo "$j" | sed 's/-/_/g')"
                        if [ "$(type -t $cmdfunc)" = "function" ]
                        then
                            info="$info $pre_cloud$cloud$post_cloud"
                        fi
                    done
                    echo "$j $info"
                done
            } | column -t
            echo
        done
        exit 0
    fi

    if [ "$1" = "--list-help" ]
    then
        list_help=true
        shift 1
    fi
done

case $output in
    terminal)
        pre_group="$blue"
        post_group="$normal"
        pre_cmd="$red"
        post_cmd="$normal"
        pre_cloud="$green"
        post_cloud="$normal"
    ;;
    ascii);;
    man)
        pre_group=".SH "
        post_group=""
        pre_cmd="\fB"
        post_cmd="\fR"
        pre_cloud='
·'
        post_cloud=""
    ;;
    htmq) ;;
    tex) ;;
esac

if [ "$list_help" = true ]
then
    for i in $all_cmd_groups
    do
        echo "${pre_group}${i#*_}${post_group}"
        tmp="$(eval echo $i)"
        for j in $tmp
        do
            helpfunc="help_$(echo "$j" | sed 's/-/_/g')"
            cmdfuncmatch="cmd_.*_$(echo "$j" | sed 's/-/_/g')"
            if [ "$(type -t $helpfunc)" = "function" ]
            then
                # This picks the first cloud implementation and extracts the arguments from there.
                arguments=" $(sed -n '/'$cmdfuncmatch'/,/^\}$/{p;/^\}/q}' moln  | grep '="\$[1-9]"' | tr -d ' ' | cut -f 1 -d '=' | tr '\n' ' ')"
                echo "${pre_cmd}$j$arguments${post_cmd}$(eval $helpfunc | head -n 1)"
                for cloud in aws azure gcloud
                do
                    cmdvar="cmd_${cloud}_$(echo "$j" | sed 's/-/_/g')"
                    cmdvar=$(echo $cmdvar | tr 'a-z' 'A-Z')
                    body=$(eval echo "\$$cmdvar")
                    if [ -n "$body" ]
                    then
                        echo -n "$pre_cloud"
                        if [ "$output" = "terminal" ] || [ "$output" = "ascii" ]
                        then
                            tabs 8
                            echo "$body" | fold -s -w 80  | sed -e "s|^|\t|g"
                            tabs -8
                        else
                            echo "$body"
                        fi
                        echo -n "$post_cloud"
                    fi
                done
            fi
        done
        echo
    done
    exit 0
fi

cloud=$1
cmd=$2
if [ "$cloud" = "" ] || [ "$cmd" = "" ]
then
    echo "Usage: moln [options] {all|aws|azure|gcloud} [command] <args>"
    echo "       -l  --list-commands List all commands"
    echo "       -lc --list-clouds   List all clouds"
    echo "       --list-help         List help"
    echo "       --output=[terminal|ascii|man|htmq|tex]"
    exit 0
fi

if  ! echo -n "$all_clouds" | grep -wq $cloud
then
    echo "Error: \"$cloud\" is not a valid cloud provider. ($all_clouds)"
    exit 1
fi

# Now check the command choosen.

if  ! echo -n "$all_cmds" | grep -wq $cmd
then
    echo "Error: \"$cmd\" is not a valid command."
    exit 1
fi

# Now remove the first two arguments.
shift 2

if [ "$cmd" = "assume-role" ]
then
    cmdfunc="cmd_${cloud}_$(echo "$cmd" | sed 's/-/_/g')"
    eval $cmdfunc "$*"
    exit $?
fi

prefunc="cmd_$(echo "$cmd" | sed 's/-/_/g')_pre"
postfunc="cmd_$(echo "$cmd" | sed 's/-/_/g')_post"

if [ ! "$(type -t $prefunc)" = "function" ]
then
    # This is the /bin/true function, not the boolean true.....
    prefunc=true
fi

if [ ! "$(type -t $postfunc)" = "function" ]
then
    if [ ! "$prefunc" = "true" ]
    then
        # The prefunc is set to something, but we have not explicit post.
        # Then use the default post.
        postfunc=cmd_columnize_post
    else
        # No post, and no pre, then just cat the output.
        postfunc=cat
    fi
fi

if [ "$cloud" = "all" ]
then
    (
        eval $prefunc "$*"
        for i in $clouds
        do
            cmdfunc="cmd_${i}_$(echo "$cmd" | sed 's/-/_/g')"
            if [ "$(type -t $cmdfunc)" = "function" ]
            then
                eval $cmdfunc "$*"
            else
                echo "Command $cmd is not implemented for provider $i!"  > /dev/stderr
            fi
        done
    ) | eval $postfunc "$*"
else
    (
        eval $prefunc "$*"
        cmdfunc="cmd_${cloud}_$(echo "$cmd" | sed 's/-/_/g')"
        if [ "$(type -t $cmdfunc)" = "function" ]
        then
            eval $cmdfunc "$*"
        else
            echo "Command $cmd is not implemented for provider $cloud!" > /dev/stderr
        fi
    ) | eval $postfunc
fi
